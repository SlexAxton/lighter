import { promises as fs } from "fs";
import grammars from "./grammars.mjs";

async function updateLibData() {
  const aliasOrIdToScope = {};
  // languages.forEach((language) => {
  //   aliasOrIdToScope[language.id] = language.scopeName;
  //   (language.aliases || []).forEach((alias) => {
  //     aliasOrIdToScope[alias] = language.scopeName;
  //   });
  // });

  grammars.forEach((g) => {
    aliasOrIdToScope[g.name] = g.scopeName;
    (g.aliases || []).forEach((alias) => {
      aliasOrIdToScope[alias] = g.scopeName;
    });
  });

  const scopeToLanguageData = {};
  // languages.forEach((language) => {
  //   scopeToLanguageData[language.scopeName] = {
  //     id: language.id,
  //     path: language.path,
  //     embeddedScopes: getDependentLangs(language.id).map((l) => l.scopeName),
  //   };
  // });
  grammars.forEach((g) => {
    scopeToLanguageData[g.scopeName] = {
      id: g.name,
      embeddedScopes: getDependentLangs(g.embedded || []).map(
        (l) => l.scopeName
      ),
    };
  });

  const nameList = grammars.map((l) => `\n  | "${l.name}"`).join("");
  const scopeList = grammars.map((l) => `\n  | "${l.scopeName}"`).join("");

  const LANG_NAMES = [...Object.keys(aliasOrIdToScope), "text", "terminal"];
  LANG_NAMES.sort();

  const content = `// generated by lib/utils/02.languages-data.mjs

export const LANG_NAMES = ${JSON.stringify(LANG_NAMES, null, 2)};
type NamesTuple = typeof LANG_NAMES;
export type LanguageAlias = NamesTuple[number];
export type LanguageName = ${nameList};
export type ScopeName = ${scopeList};

export type LanguageData = {
  id: LanguageName;
  embeddedScopes: ScopeName[];
};
  
export const aliasOrIdToScope: Record<LanguageAlias, ScopeName> = ${JSON.stringify(
    aliasOrIdToScope,
    null,
    2
  )};
export const scopeToLanguageData: Record<ScopeName, LanguageData> = ${JSON.stringify(
    scopeToLanguageData,
    null,
    2
  )};
`;

  await fs.writeFile("./src/language-data.ts", content, "utf8");
}

function getDependentLangs(embedded) {
  // console.log(embedded);
  return embedded
    .map((name) => {
      const r = grammars.find((g) => g.name === name);
      // console.log(name, r);
      return r;
    })
    .filter(Boolean);

  // if (!language) {
  //   return [];
  // }

  // const idsToExpand = [language.id];
  // const dependentLanguages = [];

  // while (idsToExpand.length) {
  //   const id = idsToExpand.shift();

  //   const alreadyExpanded = dependentLanguages.find((l) => l.id === id);

  //   if (!alreadyExpanded) {
  //     const lang = languages.find((l) => l.id === id);
  //     dependentLanguages.unshift(lang);
  //     if (lang.embeddedLangs) {
  //       idsToExpand.push(...lang.embeddedLangs);
  //     }
  //   }
  // }

  // return dependentLanguages.filter((l) => l.id !== langId);
}

await updateLibData();

console.log("Updated lib/src/language-data.ts");
